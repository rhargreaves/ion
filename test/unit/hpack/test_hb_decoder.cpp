#include <spdlog/spdlog.h>

#include <catch2/catch_test_macros.hpp>

#include "hpack/header_block_decoder.h"
#include "hpack/header_block_encoder.h"
#include "http2_frames.h"

void check_header(std::vector<ion::HttpHeader>& hdrs, size_t index, const std::string& expectedName,
                  const std::string& expectedValue) {
    REQUIRE(hdrs[index].name == expectedName);
    REQUIRE(hdrs[index].value == expectedValue);
};

TEST_CASE("headers: decodes static table entries") {
    auto dynamic_table = ion::DynamicTable{};
    auto decoder = ion::HeaderBlockDecoder{dynamic_table};

    SECTION ("static table entries only") {
        std::array<uint8_t, 3> data = {0x82, 0x84, 0x87};
        auto hdrs = decoder.decode(data);

        REQUIRE(hdrs.has_value());
        REQUIRE((*hdrs).size() == 3);  // skip over any dynamic table entries not added yet

        SECTION ("parses :method: GET") {
            check_header(*hdrs, 0, ":method", "GET");
        }

        SECTION ("parses :path: /") {
            check_header(*hdrs, 1, ":path", "/");
        }

        SECTION ("parses :scheme: https") {
            check_header(*hdrs, 2, ":scheme", "https");
        }
    }

    SECTION ("literal header field with indexed name") {
        std::array<uint8_t, 8> data = {0x41, 0x86, 0xa0, 0xe4, 0x1d, 0x13, 0x9d, 0x9};

        auto hdrs = decoder.decode(data);

        REQUIRE(hdrs);
        REQUIRE((*hdrs).size() == 1);

        SECTION ("parses :authority: localhost") {
            check_header(*hdrs, 0, ":authority", "localhost");
        }
    }

    SECTION ("literal header field without indexing") {
        auto data = std::to_array<uint8_t>({0x04, 0x84, 0x62, 0x33, 0xc9, 0xeb});

        auto hdrs = decoder.decode(data);

        REQUIRE(hdrs);
        REQUIRE((*hdrs).size() == 1);

        SECTION ("parses :path: /body") {
            check_header(*hdrs, 0, ":path", "/body");
        }
    }

    SECTION ("handles min/max indices") {
        std::array<uint8_t, 2> data = {0x81, 0xbd};
        auto hdrs = decoder.decode(data);

        REQUIRE((*hdrs).size() == 2);

        SECTION ("parses :authority: <empty>") {
            check_header(*hdrs, 0, ":authority", "");
        }

        SECTION ("parses www-authenticate: <empty>") {
            check_header(*hdrs, 1, "www-authenticate", "");
        }
    }

    SECTION ("handles out-of-range indices") {
        std::array<uint8_t, 2> data = {0x80, 0xbe};

        auto hdrs = decoder.decode(data);

        REQUIRE(!hdrs);
        REQUIRE(hdrs.error() == FrameError::ProtocolError);
    }
}

TEST_CASE("headers: decodes dynamic table entries") {
    auto dynamic_table = ion::DynamicTable{};
    auto decoder = ion::HeaderBlockDecoder{dynamic_table};

    SECTION ("stores and returns dynamic header with static header name") {
        constexpr auto req1 = std::to_array<uint8_t>({
            /* :method: GET */ 0x82,                                                    //
            /* :path: / */ 0x84,                                                        //
            /* :authority: localhost */ 0x41, 0x86, 0xa0, 0xe4, 0x1d, 0x13, 0x9d, 0x9,  //
            /* :scheme: https */ 0x87                                                   //
        });
        auto hdrs1_expected = decoder.decode(req1);
        REQUIRE(hdrs1_expected);
        auto& hdrs1 = *hdrs1_expected;

        REQUIRE(hdrs1.size() == 4);
        check_header(hdrs1, 0, ":method", "GET");
        check_header(hdrs1, 1, ":path", "/");
        check_header(hdrs1, 2, ":authority", "localhost");
        check_header(hdrs1, 3, ":scheme", "https");

        constexpr auto req2 = std::to_array<uint8_t>({0x82, 0x84, 0xbe, 0x87});
        auto hdrs2_expected = decoder.decode(req2);
        REQUIRE(hdrs2_expected);
        auto& hdrs2 = *hdrs2_expected;

        REQUIRE(hdrs1.size() == hdrs2.size());
        for (size_t i = 0; i < hdrs1.size(); ++i) {
            REQUIRE(hdrs1[i].name == hdrs2[i].name);
            REQUIRE(hdrs1[i].value == hdrs2[i].value);
        }
    }

    SECTION ("literal header field - dynamic header name") {
        constexpr auto req1 =
            std::to_array<uint8_t>({0x40, 0x82, 0x94, 0xe7, 0x83, 0x8c, 0x76, 0x7f});
        auto hdrs1_expected = decoder.decode(req1);
        REQUIRE(hdrs1_expected);
        auto& hdrs1 = *hdrs1_expected;

        REQUIRE(hdrs1.size() == 1);
        check_header(hdrs1, 0, "foo", "bar");

        constexpr auto req2 =
            std::to_array<uint8_t>({0x7e, 0x91, 0x8c, 0x76, 0x29, 0x18, 0xfd, 0xa9, 0x18, 0xec,
                                    0x52, 0x31, 0xfb, 0x52, 0x31, 0xd8, 0xa4, 0x63, 0xf7});
        auto hdrs2_expected = decoder.decode(req2);
        REQUIRE(hdrs2_expected);
        auto& hdrs2 = *hdrs2_expected;

        REQUIRE(hdrs2.size() == 1);
        check_header(hdrs2, 0, "foo", "bar baz bar baz bar baz");
    }

    SECTION ("literal header field - new name (short value, non-huffman)") {
        constexpr auto foo_hdr =
            std::to_array<uint8_t>({0x40, 0x84, 0xf2, 0xb4, 0xa7, 0x3f, 0x3, 0x62, 0x61, 0x72});

        auto hdrs = decoder.decode(foo_hdr);

        REQUIRE((*hdrs).size() == 1);
        check_header(*hdrs, 0, "x-foo", "bar");
    }

    SECTION ("literal header field - new name (long value, huffman)") {
        constexpr auto foo_hdr = std::to_array<uint8_t>(
            {0x40, 0x84, 0xf2, 0xb4, 0xa7, 0x3f, 0x9a, 0x94, 0xe7, 0x52, 0x31,
             0xd8, 0xa4, 0x63, 0xf6, 0xa4, 0xa7, 0x3a, 0x91, 0x8e, 0xc5, 0x23,
             0x1f, 0xb5, 0x25, 0x39, 0xd4, 0x8c, 0x76, 0x29, 0x18, 0xfd, 0xff});

        auto hdrs = decoder.decode(foo_hdr);

        REQUIRE((*hdrs).size() == 1);
        check_header(*hdrs, 0, "x-foo", "foo bar baz foo bar baz foo bar baz");
    }

    SECTION ("literal header field - new name, without indexing (long value, huffman)") {
        constexpr auto foo_hdr = std::to_array<uint8_t>(
            {0x00, 0x84, 0xf2, 0xb4, 0xa7, 0x3f, 0x9a, 0x94, 0xe7, 0x52, 0x31,
             0xd8, 0xa4, 0x63, 0xf6, 0xa4, 0xa7, 0x3a, 0x91, 0x8e, 0xc5, 0x23,
             0x1f, 0xb5, 0x25, 0x39, 0xd4, 0x8c, 0x76, 0x29, 0x18, 0xfd, 0xff});

        auto hdrs = decoder.decode(foo_hdr);

        REQUIRE((*hdrs).size() == 1);
        check_header(*hdrs, 0, "x-foo", "foo bar baz foo bar baz foo bar baz");
    }

    SECTION ("headers from Chrome") {
        constexpr auto hdr_block = std::to_array<uint8_t>(
            {0x82, 0x41, 0x8a, 0xa0, 0xe4, 0x1d, 0x13, 0x9d, 0x9,  0xb8, 0xf3, 0x4d, 0x33, 0x87,
             0x4,  0x86, 0x61, 0x9,  0x1a, 0x4c, 0x46, 0x3f, 0x40, 0x85, 0xae, 0xc1, 0xcd, 0x48,
             0xff, 0x86, 0xa8, 0xeb, 0x10, 0x64, 0x9c, 0xbf, 0x58, 0x86, 0xa8, 0xeb, 0x10, 0x64,
             0x9c, 0xbf, 0x40, 0x87, 0x41, 0x48, 0xb1, 0x27, 0x5a, 0xd1, 0xff, 0xb8, 0xfe, 0x6f,
             0x4f, 0x61, 0xe9, 0x35, 0xb4, 0xff, 0x3f, 0x7d, 0xe0, 0xfe, 0x42, 0xd0, 0xbf, 0x9f,
             0xa5, 0x3f, 0x9c, 0x47, 0x3c, 0xd4, 0x15, 0x4b, 0xd3, 0xd8, 0x7a, 0x4b, 0xfc, 0xfd,
             0xf7, 0x83, 0xf9, 0xb,  0x42, 0xfe, 0x7e, 0x94, 0xfe, 0x74, 0x9d, 0x31, 0x42, 0xa5,
             0xdb, 0x7,  0x54, 0x9f, 0xcf, 0xdf, 0x78, 0x3f, 0x97, 0xdf, 0xfe, 0x7f, 0x40, 0x8b,
             0x41, 0x48, 0xb1, 0x27, 0x5a, 0xd1, 0xad, 0x49, 0xe3, 0x35, 0x5,  0x2,  0x3f, 0x30,
             0x40, 0x8d, 0x41, 0x48, 0xb1, 0x27, 0x5a, 0xd1, 0xad, 0x5d, 0x3,  0x4c, 0xa7, 0xb2,
             0x9f, 0x7,  0x22, 0x6d, 0x61, 0x63, 0x4f, 0x53, 0x22, 0x40, 0x3,  0x64, 0x6e, 0x74,
             0x1,  0x31, 0x40, 0x92, 0xb6, 0xb9, 0xac, 0x1c, 0x85, 0x58, 0xd5, 0x20, 0xa4, 0xb6,
             0xc2, 0xad, 0x61, 0x7b, 0x5a, 0x54, 0x25, 0x1f, 0x1,  0x31, 0x7a, 0xd9, 0xd0, 0x7f,
             0x66, 0xa2, 0x81, 0xb0, 0xda, 0xe0, 0x53, 0xfa, 0xd0, 0x32, 0x1a, 0xa4, 0x9d, 0x13,
             0xfd, 0xa9, 0x92, 0xa4, 0x96, 0x85, 0x34, 0xc,  0x8a, 0x6a, 0xdc, 0xa7, 0xe2, 0x81,
             0x4,  0x41, 0x6e, 0x27, 0x7f, 0xb5, 0x21, 0xae, 0xba, 0xb,  0xc8, 0xb1, 0xe6, 0x32,
             0x58, 0x6d, 0x97, 0x57, 0x65, 0xc5, 0x3f, 0xac, 0xd8, 0xf7, 0xe8, 0xcf, 0xf4, 0xa5,
             0x6,  0xea, 0x55, 0x31, 0x14, 0x9d, 0x4f, 0xfd, 0xa9, 0x7a, 0x7b, 0xf,  0x49, 0x58,
             0xb,  0x42, 0x5c, 0xb,  0x81, 0x70, 0x29, 0xb8, 0x72, 0x8e, 0xc3, 0x30, 0xdb, 0x2e,
             0xae, 0xcb, 0x9f, 0x53, 0xe5, 0x49, 0x7c, 0xa5, 0x89, 0xd3, 0x4d, 0x1f, 0x43, 0xae,
             0xba, 0xc,  0x41, 0xa4, 0xc7, 0xa9, 0x8f, 0x33, 0xa6, 0x9a, 0x3f, 0xdf, 0x9a, 0x68,
             0xfa, 0x1d, 0x75, 0xd0, 0x62, 0xd,  0x26, 0x3d, 0x4c, 0x79, 0xa6, 0x8f, 0xbe, 0xd0,
             0x1,  0x77, 0xfe, 0x8d, 0x48, 0xe6, 0x2b, 0x3,  0xee, 0x69, 0x7e, 0x8d, 0x48, 0xe6,
             0x2b, 0x1e, 0xb,  0x1d, 0x7f, 0x46, 0xa4, 0x73, 0x15, 0x81, 0xd7, 0x54, 0xdf, 0x5f,
             0x2c, 0x7c, 0xfd, 0xf6, 0x80, 0xb,  0xbd, 0xf4, 0x3a, 0xeb, 0xa0, 0xc4, 0x1a, 0x4c,
             0x7a, 0x98, 0x41, 0xa6, 0xa8, 0xb2, 0x2c, 0x5f, 0x24, 0x9c, 0x75, 0x4c, 0x5f, 0xbe,
             0xf0, 0x46, 0xcf, 0xdf, 0x68, 0x0,  0xbb, 0xbf, 0x40, 0x8a, 0x41, 0x48, 0xb4, 0xa5,
             0x49, 0x27, 0x59, 0x6,  0x49, 0x7f, 0x83, 0xa8, 0xf5, 0x17, 0x40, 0x8a, 0x41, 0x48,
             0xb4, 0xa5, 0x49, 0x27, 0x5a, 0x93, 0xc8, 0x5f, 0x86, 0xa8, 0x7d, 0xcd, 0x30, 0xd2,
             0x5f, 0x40, 0x8a, 0x41, 0x48, 0xb4, 0xa5, 0x49, 0x27, 0x5a, 0xd4, 0x16, 0xcf, 0x2,
             0x3f, 0x31, 0x40, 0x8a, 0x41, 0x48, 0xb4, 0xa5, 0x49, 0x27, 0x5a, 0x42, 0xa1, 0x3f,
             0x86, 0x90, 0xe4, 0xb6, 0x92, 0xd4, 0x9f, 0x50, 0x92, 0x9b, 0xd9, 0xab, 0xfa, 0x52,
             0x42, 0xcb, 0x40, 0xd2, 0x5f, 0xa5, 0x23, 0xb3, 0xe9, 0x4f, 0x68, 0x4c, 0x9f, 0x51,
             0x8b, 0x2d, 0x4b, 0x70, 0xdd, 0xf4, 0x5a, 0xbe, 0xfb, 0x40, 0x5,  0xdf, 0x40, 0x86,
             0xae, 0xc3, 0x1e, 0xc3, 0x27, 0xd7, 0x85, 0xb6, 0x0,  0x7d, 0x28, 0x6f});

        auto hdrs = decoder.decode(hdr_block);

        REQUIRE(hdrs);
        REQUIRE((*hdrs).size() == 20);
    }

    SECTION ("returns error for invalid first bytes") {
        constexpr auto hdr_block = std::to_array<uint8_t>({0xff});

        auto hdrs = decoder.decode(hdr_block);

        REQUIRE(!hdrs);
        REQUIRE(hdrs.error() == FrameError::ProtocolError);
    }

    SECTION ("headers from Chrome w/Integer prefix continuation") {
        constexpr auto hdr_block1 = std::to_array<uint8_t>(
            {0x82, 0x41, 0x8a, 0xa0, 0xe4, 0x1d, 0x13, 0x9d, 0x9,  0xb8, 0xf3, 0x4d, 0x33, 0x87,
             0x4,  0x86, 0x61, 0x9,  0x1a, 0x4c, 0x46, 0x3f, 0x40, 0x85, 0xae, 0xc1, 0xcd, 0x48,
             0xff, 0x86, 0xa8, 0xeb, 0x10, 0x64, 0x9c, 0xbf, 0x58, 0x86, 0xa8, 0xeb, 0x10, 0x64,
             0x9c, 0xbf, 0x40, 0x87, 0x41, 0x48, 0xb1, 0x27, 0x5a, 0xd1, 0xff, 0xb8, 0xfe, 0x6f,
             0x4f, 0x61, 0xe9, 0x35, 0xb4, 0xff, 0x3f, 0x7d, 0xe0, 0xfe, 0x42, 0xd0, 0xbf, 0x9f,
             0xa5, 0x3f, 0x9c, 0x47, 0x3c, 0xd4, 0x15, 0x4b, 0xd3, 0xd8, 0x7a, 0x4b, 0xfc, 0xfd,
             0xf7, 0x83, 0xf9, 0xb,  0x42, 0xfe, 0x7e, 0x94, 0xfe, 0x74, 0x9d, 0x31, 0x42, 0xa5,
             0xdb, 0x7,  0x54, 0x9f, 0xcf, 0xdf, 0x78, 0x3f, 0x97, 0xdf, 0xfe, 0x7f, 0x40, 0x8b,
             0x41, 0x48, 0xb1, 0x27, 0x5a, 0xd1, 0xad, 0x49, 0xe3, 0x35, 0x5,  0x2,  0x3f, 0x30,
             0x40, 0x8d, 0x41, 0x48, 0xb1, 0x27, 0x5a, 0xd1, 0xad, 0x5d, 0x3,  0x4c, 0xa7, 0xb2,
             0x9f, 0x7,  0x22, 0x6d, 0x61, 0x63, 0x4f, 0x53, 0x22, 0x40, 0x3,  0x64, 0x6e, 0x74,
             0x1,  0x31, 0x40, 0x92, 0xb6, 0xb9, 0xac, 0x1c, 0x85, 0x58, 0xd5, 0x20, 0xa4, 0xb6,
             0xc2, 0xad, 0x61, 0x7b, 0x5a, 0x54, 0x25, 0x1f, 0x1,  0x31, 0x7a, 0xd9, 0xd0, 0x7f,
             0x66, 0xa2, 0x81, 0xb0, 0xda, 0xe0, 0x53, 0xfa, 0xd0, 0x32, 0x1a, 0xa4, 0x9d, 0x13,
             0xfd, 0xa9, 0x92, 0xa4, 0x96, 0x85, 0x34, 0xc,  0x8a, 0x6a, 0xdc, 0xa7, 0xe2, 0x81,
             0x4,  0x41, 0x6e, 0x27, 0x7f, 0xb5, 0x21, 0xae, 0xba, 0xb,  0xc8, 0xb1, 0xe6, 0x32,
             0x58, 0x6d, 0x97, 0x57, 0x65, 0xc5, 0x3f, 0xac, 0xd8, 0xf7, 0xe8, 0xcf, 0xf4, 0xa5,
             0x6,  0xea, 0x55, 0x31, 0x14, 0x9d, 0x4f, 0xfd, 0xa9, 0x7a, 0x7b, 0xf,  0x49, 0x58,
             0xb,  0x42, 0x5c, 0xb,  0x81, 0x70, 0x29, 0xb8, 0x72, 0x8e, 0xc3, 0x30, 0xdb, 0x2e,
             0xae, 0xcb, 0x9f, 0x53, 0xe5, 0x49, 0x7c, 0xa5, 0x89, 0xd3, 0x4d, 0x1f, 0x43, 0xae,
             0xba, 0xc,  0x41, 0xa4, 0xc7, 0xa9, 0x8f, 0x33, 0xa6, 0x9a, 0x3f, 0xdf, 0x9a, 0x68,
             0xfa, 0x1d, 0x75, 0xd0, 0x62, 0xd,  0x26, 0x3d, 0x4c, 0x79, 0xa6, 0x8f, 0xbe, 0xd0,
             0x1,  0x77, 0xfe, 0x8d, 0x48, 0xe6, 0x2b, 0x3,  0xee, 0x69, 0x7e, 0x8d, 0x48, 0xe6,
             0x2b, 0x1e, 0xb,  0x1d, 0x7f, 0x46, 0xa4, 0x73, 0x15, 0x81, 0xd7, 0x54, 0xdf, 0x5f,
             0x2c, 0x7c, 0xfd, 0xf6, 0x80, 0xb,  0xbd, 0xf4, 0x3a, 0xeb, 0xa0, 0xc4, 0x1a, 0x4c,
             0x7a, 0x98, 0x41, 0xa6, 0xa8, 0xb2, 0x2c, 0x5f, 0x24, 0x9c, 0x75, 0x4c, 0x5f, 0xbe,
             0xf0, 0x46, 0xcf, 0xdf, 0x68, 0x0,  0xbb, 0xbf, 0x40, 0x8a, 0x41, 0x48, 0xb4, 0xa5,
             0x49, 0x27, 0x59, 0x6,  0x49, 0x7f, 0x83, 0xa8, 0xf5, 0x17, 0x40, 0x8a, 0x41, 0x48,
             0xb4, 0xa5, 0x49, 0x27, 0x5a, 0x93, 0xc8, 0x5f, 0x86, 0xa8, 0x7d, 0xcd, 0x30, 0xd2,
             0x5f, 0x40, 0x8a, 0x41, 0x48, 0xb4, 0xa5, 0x49, 0x27, 0x5a, 0xd4, 0x16, 0xcf, 0x2,
             0x3f, 0x31, 0x40, 0x8a, 0x41, 0x48, 0xb4, 0xa5, 0x49, 0x27, 0x5a, 0x42, 0xa1, 0x3f,
             0x86, 0x90, 0xe4, 0xb6, 0x92, 0xd4, 0x9f, 0x50, 0x92, 0x9b, 0xd9, 0xab, 0xfa, 0x52,
             0x42, 0xcb, 0x40, 0xd2, 0x5f, 0xa5, 0x23, 0xb3, 0xe9, 0x4f, 0x68, 0x4c, 0x9f, 0x51,
             0x8b, 0x2d, 0x4b, 0x70, 0xdd, 0xf4, 0x5a, 0xbe, 0xfb, 0x40, 0x5,  0xdf, 0x40, 0x86,
             0xae, 0xc3, 0x1e, 0xc3, 0x27, 0xd7, 0x85, 0xb6, 0x0,  0x7d, 0x28, 0x6f});

        constexpr auto hdr_block2 = std::to_array<uint8_t>(
            {0x82, 0xce, 0x87, 0x4,  0x91, 0x61, 0x9,  0x1a, 0x4c, 0x46, 0x8,  0x84, 0x31,
             0x48, 0xcd, 0x52, 0xe4, 0x42, 0x3f, 0xce, 0xf0, 0x3f, 0xcd, 0xcc, 0xc9, 0xc6,
             0xcb, 0xc8, 0xca, 0x53, 0x8e, 0x49, 0x7c, 0xa5, 0x82, 0x21, 0x1f, 0x5f, 0x2c,
             0x7c, 0xfd, 0xf6, 0x80, 0xb,  0x87, 0x7f, 0x6,  0x88, 0x40, 0xe9, 0x2a, 0xc7,
             0xb0, 0xd3, 0x1a, 0xaf, 0x7f, 0x6,  0x85, 0xa8, 0xeb, 0x10, 0xf6, 0x23, 0x7f,
             0x5,  0x84, 0x42, 0x7d, 0x50, 0x5f, 0x73, 0x95, 0x9d, 0x29, 0xad, 0x17, 0x18,
             0x62, 0x83, 0x90, 0x74, 0x4e, 0x74, 0x26, 0xe3, 0xcd, 0x34, 0xcb, 0x8,  0x48,
             0xd2, 0x62, 0x31, 0xc5, 0xc4, 0x7f, 0x4,  0x3,  0x75, 0x3d, 0x30});

        spdlog::info("hdrs1");
        auto hdrs1 = decoder.decode(hdr_block1);
        REQUIRE(hdrs1.has_value());

        spdlog::info("hdrs2");
        auto hdrs2 = decoder.decode(hdr_block2);
        REQUIRE(hdrs2.has_value());
    }

    SECTION ("literal header field never index - new name (non-huffman)") {
        constexpr auto foo_hdr =
            std::to_array<uint8_t>({0x10, 0x84, 0xf2, 0xb4, 0xa7, 0x3f, 0x3, 0x62, 0x61, 0x72});

        auto hdrs = decoder.decode(foo_hdr);

        REQUIRE((*hdrs).size() == 1);
        check_header(*hdrs, 0, "x-foo", "bar");

        REQUIRE(dynamic_table.count() == 0);
    }

    SECTION ("literal header field - enforce string length limit on decode") {
        spdlog::set_level(spdlog::level::trace);
        auto encoder_dt = ion::DynamicTable{};
        auto encoder = ion::HeaderBlockEncoder{encoder_dt};

        constexpr int max_length = 4096;
        auto long_str = std::string(max_length + 1, 'a');
        auto hdr_bytes = encoder.encode({{"new", long_str}});

        auto hdrs = decoder.decode(hdr_bytes);

        REQUIRE(!hdrs);
        REQUIRE(hdrs.error() == FrameError::ProtocolError);
    }
}

TEST_CASE("headers: dynamic table management") {
    constexpr auto max_size = 120;

    auto dynamic_table = ion::DynamicTable{max_size};
    auto decoder = ion::HeaderBlockDecoder{dynamic_table};
    auto encoder_dt = ion::DynamicTable{};
    auto encoder = ion::HeaderBlockEncoder{encoder_dt};

    const auto hdr_bytes1 = encoder.encode({{"x-fo1", "ba1"}});  // 40
    const auto hdr_bytes2 = encoder.encode({{"x-fo2", "ba2"}});  // 40
    const auto hdr_bytes3 = encoder.encode({{"x-fo3", "ba3"}});  // 40
    const auto hdr_bytes4 = encoder.encode({{"x-fo4", "ba4"}});  // 40

    SECTION ("evicts headers when max size reached") {
        decoder.decode(hdr_bytes1);
        decoder.decode(hdr_bytes2);
        decoder.decode(hdr_bytes3);
        decoder.decode(hdr_bytes4);

        REQUIRE(dynamic_table.count() == 3);
        REQUIRE(dynamic_table.get(0).name == "x-fo4");
        REQUIRE(dynamic_table.get(1).name == "x-fo3");
        REQUIRE(dynamic_table.get(2).name == "x-fo2");
    }

    SECTION ("evicts headers when new max size received") {
        decoder.decode(hdr_bytes1);
        REQUIRE(dynamic_table.count() == 1);
        REQUIRE(dynamic_table.size() == 40);

        decoder.decode(hdr_bytes2);
        REQUIRE(dynamic_table.count() == 2);
        REQUIRE(dynamic_table.size() == 80);

        decoder.decode(hdr_bytes3);
        REQUIRE(dynamic_table.count() == 3);
        REQUIRE(dynamic_table.size() == 120);

        constexpr auto resize_table_to_80 = std::to_array<uint8_t>({0x3f, 0x3a});
        decoder.decode(resize_table_to_80);
        REQUIRE(dynamic_table.count() == 2);
        REQUIRE(dynamic_table.size() == 80);
    }
}
